#summary ParseParms.scala is a Scala command-line parser class.

= Introduction =

This page contains an attempt to implement a command-line parser in Scala

{{{

/*
 * ParseParms.scala
 *
 * ParseParms is an implementation of a command-line parameter parser in Scala.
 *
 * It allows you to define:
 *
 *   A Help String
 *   Parameter entries each including:
 *       name
 *       default value
 *       regular expression used for validation; defaults are used if not stated
 *       tag to indicate a required parameter; defaults to not-required
 *   A validate method to test passed arguments against defined parameters
 *
 *   A validate method parses the parameters and returns a Scala tupple object
 *   of the form (Boolean, String, Map)
 *
 *   The Boolean indicates success and Map contains merged parm values.
 *   Failure, false, includes an error message in String; Map is empty
 *
 *   The String includes an error message indicating missing required parms
 *   and/or incorrect parameter values: failed regular expression test
 *
 *   The Map object contains the merged parameter values: supplied parms and
 *   default values for absent non-required parameters.
 *
 *   Usage example is included below under Main
 *
 * jf.zarama at gmail dot com
 *
 * 2009.07.24
 */

package ca.zmatrix.utils

class ParseParms(val help: String) {

    private var parms = Map[String,List[String]]()

    def parm(name: String) = {
        parms += name -> List("", "^.*$", "0" )
        this
    }

    def parm(name: String, default: String) = {
        parms += name -> List(default, defRex(default), "0")
        this
    }

    def parm(name: String, default: String, rex: String) = {
        parms += name -> List(default, rex, "0")
        this
    }

    def parm(name: String, default: String, rex: String, req: String) = {
        parms += name -> List(default, rex,     // verify req expression
                           if( req.matches("^[01]{1}$") ) req else "0")
        this
    }

    private def defRex(default: String): String = {
        if( default.matches("^\\d+$") ) "^\\d+$" else "^.*$"
    }

    private def genMap(args: List[String] ) = { // return a Map of args
        var argsMap = Map[String,String]()      // result object
        if( ( args.length % 2 ) != 0 ) argsMap  // must have pairs: -name value
        else {                                  // to return a valid Map
            for( i <- 0.until(args.length,2) ){
                argsMap += args(i) -> args(i+1) // add -name value pair
            }
            argsMap                             // return -name value Map
        }
    }

    private def testRequired( args: Map[String,String] ) = {
        val ParmsNotSupplied = new collection.mutable.ListBuffer[String]
        for{ (key,value) <- parms               // iterate trough parms
            if value(2).matches("^1$")          // if parm is required
            if !args.contains(key)              // and it is not in args
        } ParmsNotSupplied += key               // add it to List
        ParmsNotSupplied.toList                 // empty: all required present
    }

    private def validParms( args: Map[String,String] ) = {
        val invalidParms = new collection.mutable.ListBuffer[String]
        for{ (key,value) <- args                // iterate through args
            if parms.contains(key)              // if it is a defined parm
            rex = parms(key)(1)                 // parm defined rex
            if !value.matches(rex)              // if regex does not match
        } invalidParms += key                   // add invalid arg
        invalidParms.toList                     // empty: all parms valid
    }

    private def mergeParms( args: Map[String,String] ) = {
        val mergedMap = collection.mutable.Map[String,String]()
        for{ (key,value) <- parms               // iterate through parms
            mValue = if( args.contains(key) ) args(key) else value(0)
        }   mergedMap.put( key,mValue )         // update result Map
        mergedMap                               // return mergedMap
    }

    private def mkString(l1: List[String],l2: List[String]) = {
        "\nhelp:   " + help + "\n\trequired parms missing: "  +
        ( if( !l1.isEmpty ) l1.mkString(" ")  else "" )       +
        ( if( !l2.isEmpty ) "\n\tinvalid parms:          "    +
               l2.mkString(" ") + "\n" else "" )
    }

    def validate( args: List[String] ) = {          // validate args to parms
        val argsMap   = genMap( args )              // Map of args: -name value
        val reqList   = testRequired( argsMap )     // List of missing required
        val validList = validParms( argsMap )       // List of (in)valid args
        if( reqList.isEmpty && validList.isEmpty ) {// successful return
            (true,"",mergeParms( argsMap ))         // true, "", mergedParms
        } else (false,mkString(reqList,validList),Map[String,String]())
    }
}

object Main {

  /**
   * @param args the command line arguments
   */
  def main(args: Array[String]) = {
    val helpString = "[ -p1 10 -p2 20 ] -p3 300 -p4 1400 -p5 12345"
    val pp = new ParseParms( helpString )
    pp.parm("-p1", "1")                         // optional
      .parm("-p2", "22",     "^\\d{2}$")        // optional
      .parm("-p3", "300",    "^\\d{3}$", "1")   // required
      .parm("-p4", "1400",   "^\\d{4}$", "1")   // required
      .parm("-p5", "12345",  "^\\d{5}$", "1")   // required
       //     ^     ^             ^       ^
       //     |     |             |       |
       //     name, default,  regEx,     requiredTag

    val result = pp.validate( args.toList )
    println(  if( result._1 ) result._3  else result._2 )

    // result is a tupple  ( Boolean, String, Map )
    // ._1 Boolean; false: error String contained in ._2, Map in ._3 is empty
    //              true:  successful, Map of parsed & merged parms in ._3

    System.exit(0)
  }

}


}}}